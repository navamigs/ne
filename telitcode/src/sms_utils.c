/*
 * sms_utils.c
 *
 *  Created on: 16/set/2016
 *      Author: FabioPi
 */

/*=================================================================
#Telit Extensions
#
#Copyright © 2016, Telit Communications S.p.A.
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
#Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
#Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in
#the documentation and/or other materials provided with the distribution.
#
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS``AS IS'' AND ANY EXPRESS OR IMPLIED
#WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
#DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#POSSIBILITY OF SUCH DAMAGE.
#
==============================================================*/

#include "sms_utils.h"

const UINT8 ConvertUnicodeTo0338[2][256] =
{
/*Basic Latin and Latin 1*/
   {
/* 0x00: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x08: */0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF,
/* 0x10: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x18: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x20: */0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27,
/* 0x28: */0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
/* 0x30: */0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
/* 0x38: */0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
/* 0x40: */0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
/* 0x48: */0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
/* 0x50: */0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
/* 0x58: */0x58, 0x59, 0x5A, 0x3C, 0x2F, 0x3E, 0x14, 0x11,
/* 0x60: */0xFF, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
/* 0x68: */0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
/* 0x70: */0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
/* 0x78: */0x78, 0x79, 0x7A, 0x28, 0x40, 0x29, 0x3D, 0xFF,
/* 0x80: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x88: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x90: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x98: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xA0: */0xFF, 0x40, 0xFF, 0x01, 0x24, 0x03, 0xFF, 0x5F,
/* 0xA8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xB0: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xB8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x60,
/* 0xC0: */0xFF, 0xFF, 0xFF, 0xFF, 0x5B, 0x0E, 0x1C, 0x09,
/* 0xC8: */0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xD0: */0xFF, 0x5D, 0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xFF,
/* 0xD8: */0x0B, 0xFF, 0xFF, 0xFF, 0x5E, 0xFF, 0xFF, 0x1E,
/* 0xE0: */0x7F, 0xFF, 0xFF, 0xFF, 0x7B, 0x0F, 0x1D, 0xFF,
/* 0xE8: */0x04, 0x05, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF,
/* 0xF0: */0xFF, 0x7D, 0x08, 0xFF, 0xFF, 0xFF, 0x7C, 0xFF,
/* 0xF8: */0x0C, 0x06, 0xFF, 0xFF, 0x7E, 0xFF, 0xFF, 0xFF
   },
/*Greek*/
   {
/* 0x00: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x08: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x10: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x18: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x20: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x28: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x30: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x38: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x40: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x48: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x50: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x58: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x60: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x68: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x70: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x78: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x80: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0x88: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  //0xFF, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x59, 0x00,
/* 0x90: */0xFF, 0xFF, 0xFF, 0x13, 0x10, 0xFF, 0xFF, 0xFF,  //0x00, 0x41, 0x42, 0x13, 0x10, 0x45, 0x5A, 0x48,
/* 0x98: */0x19, 0xFF, 0xFF, 0x14, 0xFF, 0xFF, 0x1A, 0xFF,  //0x19, 0x49, 0x4B, 0x14, 0x4D, 0x4E, 0x1A, 0x4F,
/* 0xA0: */0x16, 0xFF, 0xFF, 0x18, 0xFF, 0xFF, 0x12, 0xFF,  //0x16, 0x50, 0x00, 0x18, 0x54, 0x59, 0x12, 0x58,
/* 0xA8: */0x17, 0x15, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  //0x17, 0x15, 0x00, 0x59, /*0xE5*/0x65, 0x00, 0x00, 0x00,
/* 0xB0: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xB8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xC0: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xC8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xD0: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xD8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xE0: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xE8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xF0: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
/* 0xF8: */0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
   }
};

const UNICODE_CHAR Convert0338ToUnicode[2][128] =
{
   {
/* 0x00: */0x0040, 0x00A3, 0x0024, 0x00A5, 0x00E8, 0x00E9, 0x00F9, 0x00EC,
/* 0x08: */0x00F2, 0x00C7, 0x000A, 0x00D8, 0x00F8, 0x000D, 0x00C5, 0x00E5,
/* 0x10: */0x0394, 0x005F, 0x03A6, 0x0393, 0x039B, 0x03A9, 0x03A0, 0x03A8,
/* 0x18: */0x03A3, 0x0398, 0x039E, 0xFFFF, 0x00C6, 0x00E6, 0x00DF, 0x00C9,
/* 0x20: */0x0020, 0x0021, 0x0022, 0x0023, 0x00A4, 0x0025, 0x0026, 0x0027,
/* 0x28: */0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
/* 0x30: */0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
/* 0x38: */0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
/* 0x40: */0x00A1, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
/* 0x48: */0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
/* 0x50: */0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
/* 0x58: */0x0058, 0x0059, 0x005A, 0x00C4, 0x00D6, 0x00D1, 0x00DC, 0x00A7,
/* 0x60: */0x00BF, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
/* 0x68: */0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
/* 0x70: */0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
/* 0x78: */0x0078, 0x0079, 0x007A, 0x00E4, 0x00F6, 0x00F1, 0x00FC, 0x00E0
   },
   {
/* 0x00: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x08: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x10: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x005E, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x18: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x20: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x28: */0x007B, 0x007D, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x005C,
/* 0x30: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x38: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x005B, 0x007E, 0x005D, 0xFFFF,
/* 0x40: */0x007C, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x48: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x50: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x58: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x60: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x20AC, 0xFFFF, 0xFFFF,
/* 0x68: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x70: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
/* 0x78: */0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF
   }
};

/*
Function: FromUnicodeTo0338Spec

Function converts between unicode and 0338, minding the fact that
in order to use C strings functions the @ char has been replaced by 0xFF

*/
UINT8* FromUnicodeTo0338Spec( UINT8* des, UNICODE_CHAR*  src, UINT16 len )
{
  UINT16 i, j;
  UNICODE_CHAR tmp = 0;

  for ( j =0, i = 0; i < len; i++, j++)
  {
    if(src[i] == 0x0040) //ASCII @
      des[j]= (UINT8)GSM338_REPLACE_CHAR;
    else
    {
      tmp = (src[i] >> 8) & BMASK;

      if((tmp == 0x03) )
      {
        //			des[j++] = 	ESCAPEEXT;
        des[j] = ConvertUnicodeTo0338[1][src[i] & BMASK];
      }
      else if(tmp == 0)
      {
        if ( (src[i]>0x5A && src[i]<0x5F) || (src[i]>0x7A && src[i]<0x7F) )
        {
          des[j++] = ESCAPEEXT;
          des[j] = ConvertUnicodeTo0338[0][src[i] & BMASK];
        }
        else
          des[j] = ConvertUnicodeTo0338[0][src[i] & BMASK];
      }
    }
  }
  return des;
}

/*
Function: FromUnicodeTo0338Spec

*/


/*
Function: From0338ToUnicodeSpec

Function converts between 0338 and unicode formats.
Function requires that the 0338 string has @ already been ubstituted with 0xFF to
ease the handling.

*/

UNICODE_CHAR* From0338ToUnicodeSpec(UNICODE_CHAR* des, UINT8* src, UINT16 len )
{
	UINT16 i, j;

	for ( j = 0, i = 0; i < len; i++, j++ )
	{
		if(src[i] == (UINT8)GSM338_REPLACE_CHAR)
			des[j] = 0x0040;
		else
		{
			src[i] &=  DEFAULTMASK;
			if( src[i] == ESCAPEEXT )
			{
				i++;
				des[j] = Convert0338ToUnicode[1][src[i]];
				if( (des[j]) == 0xFFFF )
					des[j] = Convert0338ToUnicode[0][src[i]];
			}
			else
			{
				des[j] = Convert0338ToUnicode[0][src[i]];
			}
		}
	}
	des[j] = STRING_TERMINATOR;
	return 	 des;
}


CODING_SCHEME parseSchemeFromDCS(CHAR dcs)
{
	CODING_SCHEME scheme;

	switch(dcs >> 4)  /*top 4 bits*/
	{
		 case 0x0: /*default alphabet (7 bit coding of User Data)*/
			scheme = CODING_7_BIT;
			break;
		 case 0xF: /*coding is not gsm default, check lower bits*/
			 if (dcs & 0x04  == 0) //bit 2 = 0 -> Default alphabet (7 bit data coding in User data)
			 {
				 scheme = CODING_7_BIT;
			 }
			 else
			 {
				 switch(dcs & 0x03) /*filter only bit 1 and 0*/
				 {
					 case 0:
						 scheme = CODING_8_BIT_CL0;
						 break;
					 case 1:
						 scheme = CODING_8_BIT_CL1;
						 break;
					 case 2:
						 scheme = CODING_8_BIT_CL2;
						 break;
					 case 3:
						 scheme = CODING_8_BIT_CL3;
						 break;
				 }
			 }
			 break;
		 default:
			 scheme = CODING_7_BIT;
			 break;
	}

	return scheme;
}

/*
Function: FromRAWToASCII

Function converts Raw text data to ASCII 1Byte formats. Data can be truncated.
*/
char* FromRAWToASCII(char* des, char *src,  UINT16 len )
{
	UINT8 i;
	UNICODE_CHAR out[161];

	for (i=0; i< len; i++)
	{
		//LOG_VERB("src[%d] = %02X\r\n", i , src[i]);
		if (src[i] == 0x00)
		{
			//LOG_INFO("@ found\r\n");

			src[i] = GSM338_REPLACE_CHAR; /*Replace @ (0x00 in 3.38 standard) with 0xFF for further handling*/
		}
	}

	From0338ToUnicodeSpec(out, src, len);

	for ( i=0; i < len; i++ )
	{
		des[i] = (UINT8) (out[i]);
	}
	des[i] = STRING_TERMINATOR;

	return des;
}

/*
Function: ASCIIToRaw

Function converts ASCII 1Byte formats to Raw text data. (FIXME:???Data can be truncated???.)
*/
char* FromASCIIToRaw(char* des, char *src,  UINT16 len )
{
	UNICODE_CHAR in[161];
	int i;

	for ( i=0; i < len; i++ )
	{
		in[i] = ((UNICODE_CHAR) src[i] ) & (0x00FF);
	}

	FromUnicodeTo0338Spec(des,in, len);
	for (i=0; i< len; i++)
	{
		if (des[i] == GSM338_REPLACE_CHAR)
		{
			des[i] = 0x00; /*Replace  0xFF into 0x00  (@ in 3.38 standard)*/
		}
	}

	return des;
}

